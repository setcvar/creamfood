setthreadcontext(7)

local commands = {}
local alias = {}
local events = {}
local plugins = {}
local command_history = {}

local PLAYERS = game:GetService("Players")
local LOCALPLAYER = PLAYERS.LocalPlayer
local CHARACTER = LOCALPLAYER.Character or LOCALPLAYER.CharacterAdded:Wait()
local HUMANOID = CHARACTER.Humanoid

local function mAddCMD(cmd , data)
    table.insert(commands, data)
end

local function addcmd(cmd, _alias, callback)
    commands[cmd] = callback
	if _alias == "" then return end
    alias[_alias] = cmd
end

function Notify (message, color, size)
    game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {
        Text = message,
        Color = color,
        FontSize = Enum.FontSize["Size" .. tostring(size)]
    })
end

local function FindPlayer (Name)
    if Name == nil then return nil end
    
    if Name == "all" then
        return PLAYERS:GetPlayers()
    elseif Name == "others" then
        local temp_table = {}
        for index, value in pairs (PLAYERS:GetPlayers()) do if value ~= LOCALPLAYER then table.insert (temp_table, value) end end
        return temp_table
    end

    for index, value in pairs (PLAYERS:GetPlayers()) do
        if string.lower (value.Name):match("^" .. string.lower (Name)) then
            return value
        end
    end
    return nil
end


function RunCMD (command)
    local list = {}

    for word in string.gmatch (command, "%g+") do
        table.insert (list, tostring(word))
    end

    local cmd = list[1]

    if not commands[cmd] then
        for index, value in pairs (alias) do
            if index == cmd then
                cmd = value
            end
        end
    end

    if not cmd then return end

    local function Run (...)
        local playerInstance
        local args = {...}
        if typeof (args[1]) == "Instance" then
            playerInstance = args[1]
            table.remove (args, 1)

            local success, result = pcall ( coroutine.wrap (function()
                commands[cmd] (playerInstance, table.concat(args, " "))
            end) )
    
            return success, result
        end

        local success, result = pcall ( coroutine.wrap (function()
            commands[cmd] (table.concat(args, " "))
        end) )

        return success, result
    end

    local player = FindPlayer (list[2])
    if player then
        table.remove (list, 1)
        table.remove (list, 1)

        local arguments = table.concat (list, " ")
        local success, result = Run (player,arguments)
        if success then table.insert (command_history, tostring(cmd)) return end
        if result then
            Notify (tostring(result), Color3.fromRGB(255,0,0), 18)
        end
    else
        table.remove (list, 1)

        local arguments = table.concat (list, " ")
        local success, result = Run (arguments)
        if success then table.insert (command_history, tostring(cmd)) return end
        if result then
            Notify (tostring(result), Color3.fromRGB(255,0,0), 18)
        end
    end

end

function findcommand(cmd_name)
    for index, value in pairs ( commands ) do
        if index == cmd_name then
            return index
        end
    end

    for index, value in pairs (alias) do
        if index == cmd_name then
            return index
        end
    end
end

local function _print ( _string )
    print ( _string )
end

local function walkspeed ( int )
    game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = int
end

local function jumppower ( int )
    if tonumber(int) <= 0 then int = game.Players.LocalPlayer.Character.Humanoid.JumpPower end
    game.Players.LocalPlayer.Character.Humanoid.JumpPower = tonumber ( int )
end

local function setmaxfps ( int )
    if setfpscap then
        setfpscap ( int )
    end
end

local function antiafk ( )
    antiafk = game.Players.LocalPlayer.Idled:Connect(function()
        for i,v in pairs(getconnections(game.Players.LocalPlayer.Idled)) do
            v:Disable()
            v:Disconnect()
        end
    end)
    table.insert(events, "antiafk")
end

local function unantiafk ( )
    if events.antiafk then antiafk:Disconnect() end
    table.remove(events, table.find(events, "antiafk"))
end

local function spin( int )
    local BodyAngularVelocity = Instance.new( "BodyAngularVelocity" )
    BodyAngularVelocity.Parent = game.Players.LocalPlayer.Character.HumanoidRootPart
    BodyAngularVelocity.AngularVelocity = Vector3.new( 0, tonumber( int ), 0 )
    BodyAngularVelocity.MaxTorque = Vector3.new( 0, math.huge, 0 )
    table.insert( events, "spin" )
end

local function unspin ( )
    game.Players.LocalPlayer.Character.HumanoidRootPart.BodyAngularVelocity:Destroy()
    table.remove(events, table.find(events, "spin"))
end

local function clearevents ( )
    for index, value in pairs ( events ) do
        if value:IsA ( "Connection" ) or value:IsA ( "RBXScriptConnection" ) then value:Disconnect(); table.remove ( events, index ); continue end
        table.remove ( events, index )
    end
end

local function noclip ( )
    local function _noclip ( )
        for index, value in pairs (game.Players.LocalPlayer.Character:GetDescendants()) do
            if value:IsA("BasePart") and value.CanCollide == true then
                value.CanCollide = false
            end
        end
    end
    getgenv().__noclip = game:GetService("RunService").Stepped:Connect(_noclip)
    table.insert( events, "noclip" )
end

local function clip ( )
    local event = table.find( events, "noclip" )
    if event then getgenv().__noclip:Disconnect() end
end

local function changestate ( state )
    game.Players.LocalPlayer.Character.Humanoid:ChangeState( Enum.HumanoidStateType [ state ] )
end

local function jump ( )
    game.Players.LocalPlayer.Character.Humanoid:ChangeState( Enum.HumanoidStateType.Jumping )
end

local function sit ( )
    game.Players.LocalPlayer.Character.Humanoid.Sit = true
end

local function colorful_world ( )
    local rand = Random.new ( game.Players.LocalPlayer.UserId + (100 / 2 * 6 + 2 - 1) + (math.random ( 0, math.random ( 0, 49604212 ) ) * 0.5 ) - 6 )
    for index, value in pairs ( workspace:GetDescendants() ) do
        if value:IsA ( "BasePart" ) or value:IsA ( "Part" ) then
            value.Color3 = Color3.fromRGB ( rand:NextNumber (0, 255), rand:NextNumber (0, 255), rand:NextNumber (0, 255) )
        end
    end
end

local function drugs ( )
    math.randomseed ( game.Players.LocalPlayer.UserId + (100 / 2 * 6 + 2 - 1) + (math.random ( 0, math.random ( 0, 49604212 ) ) * 0.5 ) - 6 )
    for index, value in pairs ( workspace:GetDescendants() ) do
        if value:IsA ( "BasePart" ) or value:IsA ( "Part" ) then
            value.Color = Color3.fromRGB ( math.random ( 0, 255 ), math.random ( 0, 255 ), math.random ( 0, 255 ) )
        end
    end
    for i,v in pairs ( game.Lighting:GetDescendants() ) do
        if v:IsA ( "Atmosphere" ) or v:IsA ( "Sky" ) then v:Destroy() end
        Instance.new("Atmosphere", game.Lighting)
        Instance.new("Sky", game.Lighting)
    end
    game:GetService("RunService").RenderStepped:Connect( function ( )
        game.Lighting.ClockTime = math.random ( 0, 24 )
        game.Lighting.Brightness = math.random ( 0, 10 )
        game.Lighting.Atmosphere.Density = math.random ( 0, 1 )
        game.Lighting.Atmosphere.Offset = math.random ( 0, 1 )
        game.Lighting.Atmosphere.Color = Color3.fromRGB ( math.random ( 0, 255 ), math.random ( 0, 255 ), math.random ( 0, 255 ) )
        game.Lighting.Atmosphere.Decay = Color3.fromRGB ( math.random ( 0, 255 ), math.random ( 0, 255 ), math.random ( 0, 255 ) )
        game.Lighting.Atmosphere.Glare = math.random ( 0, 10 )
    
        game.Lighting.Atmosphere.Haze = math.random ( 0, 10 )
    end)
end


--[[
local lastMessage
local function CreateChatLogMessage ( message, parent )
    local label = Instance.new ("TextLabel")
    label.Parent = parent
    label.BackgroundTransparency = 1
    label.Size = UDim2.new (0,329,0,30)
    label.TextColor3 = Color3.fromRGB(255,255,255)
    label.TextWrapped = true
    label.Text = message
    label.TextXAlignment = Enum.TextXAlignment.Left
    if lastMessage then
        label.Position = lastMessage.Position + UDim2.new(0,0,0,20)
        lastMessage = label
        return label
    else
        label.Position = UDim2.new (0,0,0,0)
        lastMessage = label
        return label
    end
end

local CHATLOG_ScreenGui = Instance.new ("ScreenGui")
CHATLOG_ScreenGui.Parent = gethui() or game.CoreGui
CHATLOG_ScreenGui.Enabled = false

local CHATLOG_Frame = Instance.new ("Frame")
CHATLOG_Frame.Parent = CHATLOG_ScreenGui
CHATLOG_Frame.BackgroundColor3 = Color3.fromRGB (98, 220, 184)
CHATLOG_Frame.BorderSizePixel = 0
CHATLOG_Frame.Size = UDim2.new (0, 341,0, 299)
CHATLOG_Frame.Position = UDim2.new (0.237, 0,0.34, 0)

local CHATLOG_SFrame = Instance.new ("ScrollingFrame")
CHATLOG_SFrame.Parent = CHATLOG_Frame
CHATLOG_SFrame.BackgroundColor3 = Color3.fromRGB (30,30,30)
CHATLOG_SFrame.BorderSizePixel = 0
CHATLOG_SFrame.Size = UDim2.new (0, 341,0, 291)
CHATLOG_SFrame.Position = UDim2.new (0,0,0,0)
CHATLOG_SFrame.ScrollBarImageColor3 = Color3.fromRGB(255,255,255)
CHATLOG_SFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y]]
local function chatlog ( player )

    
    --CHATLOG_ScreenGui.Enabled = true
    player.Chatted:Connect( function ( message )
        getgenv().chatlog_messages = {}
        table.insert( chatlog_messages, player.Name .. " - " .. message )
        --CreateChatLogMessage ( "[" .. player.Name .. "]: " .. message, CHATLOG_SFrame )
    end)
    --Notify ("player.Chatted is not working", Color3.fromRGB(200,0,0), 18)
end

local function chatlog_everyone ( )
    
    for index, value in pairs (game.Players:GetPlayers()) do
        chatlog ( value )
    end
end

local function save_chatlogs ( )
    if writefile then writefile ( "creamfood_chatlogs.txt",  table.concat(getgenv().chatlog_messages, "\n"))
    else
        Notify ("Oops! Something gone wrong", Color3.fromRGB(200,0,0), 18)
    end
end

local function _goto ( _string )
    if GetPlayer ( _string ) == game.Players.LocalPlayer then return end
    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = GetPlayer ( _string ).Character.HumanoidRootPart.CFrame
end

local function rejoin ( )
    game.Players.LocalPlayer:Kick()
    wait()
    if #game.Players:GetPlayers() <= 1 then
        game:GetService ( "TeleportService" ):Teleport ( game.PlaceId, game.Players.LocalPlayer )
    else
        game:GetService ( 'TeleportService' ):TeleportToPlaceInstance ( game.PlaceId, game.JobId, game.Players.LocalPlayer )
    end
end

local function Freeze ( name )

    local function Freeze ( instance )
        if instance:IsA("BasePart") and instance.Anchored == false then
            instance.Anchored = true
        end
    end

    if name == "all" then
        for index, value in pairs (game.Players:GetPlayers()) do
            for i,v in pairs (value.Character:GetChildren()) do
                Freeze(v)
            end
        end
        return
    end

    if name == "others" then
        for index, value in pairs (game.Players:GetPlayers()) do
            if value ~= game.Players.LocalPlayer then
                for i,v in pairs (value.Character:GetChildren()) do
                    Freeze (v)
                end
            end
        end
        return
    end

    local player = GetPlayer (name)
    for index, value in pairs (player.Character:GetChildren()) do
        Freeze (value)
    end
    
end

local function Thaw ( _string )
    for index, value in pairs ( GetPlayer ( _string ).Character:GetDescendants ( ) ) do
        if value:IsA ( "BasePart" ) and value.Anchored == true or value:IsA ( "Part" ) and value.Anchored == true then
            value.Anchored = false
        end
    end
end

local function Thaw ( name )

    local function Thaw ( instance )
        if instance:IsA("BasePart") and instance.Anchored == true then
            instance.Anchored = false
        end
    end

    if name == "all" then
        for index, value in pairs (game.Players:GetPlayers()) do
            for i,v in pairs (value.Character:GetChildren()) do
                Thaw(v)
            end
        end
        return
    end

    if name == "others" then
        for index, value in pairs (game.Players:GetPlayers()) do
            if value ~= game.Players.LocalPlayer then
                for i,v in pairs (value.Character:GetChildren()) do
                    Thaw (v)
                end
            end
        end
        return
    end

    local player = GetPlayer (name)
    for index, value in pairs (player.Character:GetChildren()) do
        Thaw (value)
    end
    
end

local function Hitbox ( )
    for index, value in pairs ( workspace:GetDescendants ( ) ) do
        if value:IsA ( "BasePart" ) and value.Transparency <= 0 or value:IsA ( "Part" ) and value.Transparency <= 0 then
        local SelectionBox = Instance.new ( "SelectionBox" )
        SelectionBox.Parent = value
        SelectionBox.Color3 = Color3.fromRGB ( 201, 248, 255 )
        SelectionBox.LineThickness = 0.015
        SelectionBox.Adornee = value
    
        elseif value:IsA ( "BasePart" ) and value.Transparency > 0 or value:IsA ( "Part" ) and value.Transparency > 0 then
            local SelectionBox = Instance.new ( "SelectionBox" )
            SelectionBox.Parent = value
            SelectionBox.Color3 = Color3.fromRGB ( 255, 201, 252 )
            SelectionBox.LineThickness = 0.015
            SelectionBox.Adornee = value
        end
    end
end

local function PotatoMode ( )
    game.Lighting.FogEnd = math.huge
	game.Lighting.Ambient = Color3.fromRGB ( 255, 255, 255 )
	game.Lighting.GlobalShadows = false

    for index, value in pairs ( workspace:GetDescendants ( ) ) do
        if value:IsA ( "Part" ) or value:IsA ( "BasePart" ) then value.Material = Enum.Material.SmoothPlastic end
        if value:IsA ( "Decal" ) then value:Destroy() end
        if value:IsA ( "UnionOperation" ) then value.RenderFidelity = Enum.RenderFidelity.Performance; value.Material = Enum.Material.SmoothPlastic end
        if value:IsA ( "Atmosphere" ) or value:IsA ( "Sky" ) or value:IsA ( "BloomEffect" ) or value:IsA ( "ColorCorrectionEffect" ) or value:IsA ( "BlurEffect" ) or value:IsA ( "DepthOfFieldEffect" ) or value:IsA ( "SunRaysEffect" ) then value:Destroy() end
        if sethiddenproperty then sethiddenproperty(game.Lighting, "Technology", "Compatibility") end
    end
end

local function ExtremePotatoMode ( )
    game.Lighting.FogEnd = math.huge
	game.Lighting.Ambient = Color3.fromRGB ( 255, 255, 255 )
	game.Lighting.GlobalShadows = false

    for index, value in pairs ( workspace:GetDescendants ( ) ) do
        if value:IsA ( "Part" ) or value:IsA ( "BasePart" ) then value.Material = Enum.Material.SmoothPlastic; value.Shape = Enum.PartType.Block end
        if value:IsA ( "Decal" ) then value:Destroy() end
        if value:IsA ( "UnionOperation" ) then value:Destroy() end
        if value:IsA ( "Atmosphere" ) or value:IsA ( "Sky" ) or value:IsA ( "BloomEffect" ) or value:IsA ( "ColorCorrectionEffect" ) or value:IsA ( "BlurEffect" ) or value:IsA ( "DepthOfFieldEffect" ) or value:IsA ( "SunRaysEffect" ) then value:Destroy() end
        if sethiddenproperty then sethiddenproperty(game.Lighting, "Technology", "Compatibility") end
        if value:IsA ( "Shirt" ) or value:IsA ( "Pants" ) or value:IsA ( "Accessory" ) then value:Destroy() end
        if value:IsA ( "Beam" ) or value:IsA ( "Explosion" ) or value:IsA ( "Fire" ) or value:IsA ( "ParticleEmitter" ) or value:IsA ( "Sparkles" ) or value:IsA ( "Trail" ) then value:Destroy() end
        if value:IsA ( "BlockMesh" ) or value:IsA ( "SpecialMesh" ) then value:Destroy() end
        if value:IsA ( "Texture" ) then value:Destroy()
    end
    if workspace.CurrentCamera:FindFirstChildWhichIsA ( "Clouds" ) then workspace:FindFirstChildWhichIsA ( "Clouds" ):Destroy() end
    for index, value in pairs ( game.Players:GetPlayers() ) do
        for _, value2 in pairs ( value.Character:GetDescendants ( ) ) do
            if value2:IsA ( "Shirt" ) or value2:IsA ( "Pants" ) or value2:IsA ( "Accessory" ) then value2:Destroy() end
        end
    end
end
end

local function Gravity ( int )
	workspace.Gravity = tonumber ( int )
end

local function FireClickDetectors ( )
	for index, value in pairs ( workspace:GetDescendants( ) ) do
		if value:IsA ( "ClickDetector" ) then fireclickdetector ( value ) end
	end
end

local function SetCreatorId ( )
	game.Players.LocalPlayer.UserId = game.CreatorId
end

local function View ( player )
	if GetPlayer ( player ) then workspace.CurrentCamera.CameraSubject = GetPlayer ( player ).Character.Humanoid end
end

local function Unview ( )
	workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character.Humanoid
end

local function LoopDay ( ... )
	local arguments = { ... } -- [1] = <opcional> segundos
	if arguments[1] then
		day_loop = game:GetService("RunService").RenderStepped:Connect( function ( )
			game.Lighting.ClockTime = 14.5
		end)

		coroutine.create( coroutine.resume ( function ()
			wait ( tonumber(arguments[1]) )
			day_loop:Disconnect()
		end))

		table.insert ( events, "loopday 1" )
		
	else
		day_loop = game:GetService("RunService").RenderStepped:Connect( function ( )
			game.Lighting.ClockTime = 14.5
		end)
		table.insert ( events, "loopday 0" )
	end
end

local function UnLoopDay ( )
	if table.find ( events,  "loopday 0" ) or table.find (events, "loopday 1") then day_loop:Disconnect() end
end

local function LoopNight ( ... )
	local arguments = { ... } -- [1] = <opcional> segundos
	if arguments[1] then
		day_loop = game:GetService("RunService").RenderStepped:Connect( function ( )
			game.Lighting.ClockTime = 0
		end)

		coroutine.create( coroutine.resume ( function ()
			wait ( tonumber(arguments[1]) )
			day_loop:Disconnect()
		end))

		table.insert ( events, "loopnight 1" )
		
	else
		day_loop = game:GetService("RunService").RenderStepped:Connect( function ( )
			game.Lighting.ClockTime = 0
		end)
		table.insert ( events, "loopnight 0" )
	end
end

local function UnLoopNight ( )
	if table.find ( events,  "loopnight 0" ) or table.find ( events, "loopnight 1" ) then day_loop:Disconnect() end
end

local function IsR15()
	if game.Players.LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R15 then
		return 1; else return 0; end
end

local function Halve ( )
	if ISR15() == 1 then game.Players.LocalPlayer.Character.LowerTorso.WaistRigAttachment:Destroy() end
end

local function InfJump ( )
	getgenv().infinite_jump = game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessedEvent)
		if input == Enum.KeyCode.Space and not gameProcessedEvent then
            game.Players.LocalPlayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
	end)
	table.insert ( events, "infinite_jump" )
end

local function NoInfJump ( )
	if table.find ( events, "infinite_jump" ) then
        getgenv().infinite_jump:Disconnect()
        table.remove ( events, table.find( events, "infinite_jump" ) )
    end
end

local function NoSit ( )
	getgenv().nosit = game:GetService("RunService").RenderStepped:Connect(function()
		if game.Players.LocalPlayer.Character.Humanoid:GetState() == Enum.HumanoidStateType.Seated then game.Players.LocalPlayer.Character.Humanoid:ChangeState( Enum.HumanoidStateType.Jumping ) end
	end)
	table.insert ( events, "nosit" )
end

local function UnNosit ( )
	if table.find ( events, "nosit" ) then getgenv().nosit:Disconnect(); table.remove ( events, table.find ( events, "nosit" ) ) end
end

local function WalkTo ( _string )
	getgenv().walkto = game:GetService("RunService").RenderStepped:Connect (function()
		game.Players.LocalPlayer.Character.Humanoid:MoveTo ( GetPlayer ( _string ).Character.HumanoidRootPart.Position )
	end)
	table.insert ( events, "walkto" )
end

local function UnWalkto ( )
	if table.find ( events, "walkto" ) then getgenv().walkto:Disconnect(); table.remove ( events, table.find ( events, "walkto" ) ) end
end

local function Commands ( )
    local index = 0
    for __, _ in pairs ( commands ) do index += 1 end;
	print ( "Comandos: " .. tostring ( index ) )
	for index, value in pairs ( commands ) do
		print ( index )
	end
    Notify ("Press F9 to view the commands", Color3.fromRGB(30,30,30), 18)
end

local function ShiftSpeed ( int )
    table.insert ( events, "imspeed" )
    getgenv().shift = game:GetService ( "UserInputService" ).InputBegan:Connect (function(input, gameProcessedEvent)
        if input == Enum.KeyCode.LeftShift and not gameProcessedEvent then game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = int end
    end)
    getgenv().shift_end = game:GetService( "UserInputService" ).InputEnded:Connect (function(input, gameProcessedEvent)
        if input == Enum.KeyCode.LeftShift and not gameProcessedEvent then game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 16 end
    end)
end

local function UnShiftSpeed ( )
    if table.find ( events, "imspeed" ) then getgenv().shift:Disconnect(); getgenv().shift_end:Disconnect() end
end

local function Spam ( _string )
    local event = game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest
    getgenv().spam = true
    while wait ( getgenv ( ).spamspeed ) and getgenv().spam == true do
        event:FireServer ( _string, "All" )
    end

    table.insert ( events, "spam" )
end

local function PMSpam ( _string2, _string )
    local event = game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest
    getgenv().pmspam = true
    while wait ( getgenv ( ).spamspeed ) and getgenv().pmspam == true do
        event:FireServer ( _string2, GetPlayer ( _string ) )
    end
    table.insert ( events, "pmspam" )
end

local function SpamSpeed ( int )
    getgenv().spamspeed = int
end

local function UnSpam ( )
    if getgenv ( ).spam or table.find ( events, "spam" ) then
        getgenv().spam = false
        table.remove ( events, table.find ( events, "spam" ) )
    end
end

local function UnPMSpam ( )
    if getgenv ( ).spam or table.find ( events, "pmspam" ) then
        getgenv().pmspam = false
        table.remove ( events, table.find ( events, "pmspam" ) )
    end
end

local function NoRotate ( )
    game.Players.LocalPlayer.Character.Humanoid.AutoRotate = false
end

local function UnNoRotate ( )
    game.Players.LocalPlayer.Character.Humanoid.AutoRotate = true
end

local function Bhop ( )
    if getgenv().bhop or table.find ( events, "bhop" ) then return end
    getgenv().bhop = game:GetService ( "RunService" ).Stepped:Connect(function()
        if game.Players.LocalPlayer.Character.Humanoid.FloorMaterial ~= Enum.Material.Air then RunCMD ( "jump" ) end
    end)
    table.insert( events, "bhop" )
end

local function StopBhop( )
    if getgenv().bhop or table.find ( events, "bhop" ) then
        getgenv().bhop:Disconnect()
        table.remove ( events, table.find ( events, "bhop" ) )
    end
end

local function DeleteHats ( )
    game.Players.LocalPlayer.Character.Humanoid:RemoveAccessories()
end

local function DropHats ( )
    for index, value in pairs ( game.Player.LocalPlayer.Character.Humanoid:GetAccessories ( ) ) do
        value.Parent = workspace
    end
end

local function SpamDecal ( assetID )

    local function CreateDecal ( part, face )
        local decal = Instance.new ( "Decal" )
        decal.Parent = part
        decal.Color3 = Color3.fromRGB ( 0, 0, 0 )
        decal.Texture = "http://www.roblox.com/asset/?id=" .. toumber ( assetID )
        decal.Transparency = 0
        decal.Face = face
        decal.Name = game:GetService ( "HttpService" ):GenerateGUID ( false )
    end

    for index, value in pairs ( workspace:GetDescendants ( ) ) do
        if not value:IsA ( "Part" ) or not value:IsA ( "BasePart" ) then return end
        --[[
        CreateDecal ( value, Enum.NormalId.Top )
        CreateDecal ( value, Enum.NormalId.Bottom )
        CreateDecal ( value, Enum.NormalId.Left )
        CreateDecal ( value, Enum.NormalId.Right )
        CreateDecal ( value, Enum.NormalId.Back )
        CreateDecal ( value, Enum.NormalId.Front )
        ]]
        for i,v in pairs (Enum.NormalId) do
            CreateDecal (value, i)
        end
    end
end

local function SpamTextures ( assetID, StudsPerTileU, StudsPerTileV )

    local function CreateTexture ( part, face, StudsPerTileU, StudsPerTileV )
        local texture = Instance.new ( "Texture" )
        texture.Parent = part
        texture.Color3 = Color3.fromRGB ( 0, 0, 0 )
        texture.Texture = "http://www.roblox.com/asset/?id=" .. tonumber ( assetID )
        texture.Transparency = 0
        texture.Face = face
        texture.Name = game:GetService ( "HttpService" ):GenerateGUID ( false )
        texture.StudsPerTileU = StudsPerTileU
        texture.StudsPerTileV = StudsPerTileV
    end

    for index, value in pairs ( workspace:GetDescendants ( ) ) do

        CreateTexture ( value, Enum.NormalId.Top, StudsPerTileU, StudsPerTileV  )
        CreateTexture ( value, Enum.NormalId.Bottom, StudsPerTileU, StudsPerTileV )
        CreateTexture ( value, Enum.NormalId.Left, StudsPerTileU, StudsPerTileV )
        CreateTexture ( value, Enum.NormalId.Right, StudsPerTileU, StudsPerTileV )
        CreateTexture ( value, Enum.NormalId.Back, StudsPerTileU, StudsPerTileV )
        CreateTexture ( value, Enum.NormalId.Front, StudsPerTileU, StudsPerTileV )

    end

end

local function DestroyEverything (  )

    for index, value in pairs ( workspace:GetChildren ( ) ) do
        value:Destroy ( )
    end

end

local function SetShirt ( assetID )

    if game.Players.Character and game.Players.LocalPlayer.Character:FindFirstChild("Shirt") then
        game.Players.LocalPlayer.Character:FindFirstChildWhichIsA ( "Shirt" ).ShirtTemplate = "http://www.roblox.com/asset/?id=" .. assetID
        return
    end
    
    Instance.new ( "Shirt", game.Players.LocalPlayer.Character )
    game.Players.LocalPlayer.Character:FindFirstChildWhichIsA ( "Shirt" ).ShirtTemplate = "http://www.roblox.com/asset/?id=" .. assetID
end

local function SetPants ( assetID )
    if game.Players.Character and game.Players.LocalPlayer.Character:FindFirstChild("Pants") then
        game.Players.LocalPlayer.Character:FindFirstChildWhichIsA ( "Pants" ).PantsTemplate = "http://www.roblox.com/asset/?id=" .. assetID
        return
    end
    
    Instance.new ( "Pants", game.Players.LocalPlayer.Character )
    game.Players.LocalPlayer.Character:FindFirstChildWhichIsA ( "Pants" ).PantsTemplate = "http://www.roblox.com/asset/?id=" .. assetID
end

local function HipHeight ( studs )

    if not game.Players.LocalPlayer.Character then
        game.Players.LocalPlayer.Character.CharacterAdded:Wait()
        game.Players.LocalPlayer.Character.Humanoid.HipHeight = tonumber ( studs )
        return
    end
    game.Players.LocalPlayer.Character.Humanoid.HipHeight = tonumber ( studs )
end

local function RequiresNeck ( bool )

    if not game.Players.LocalPlayer.Character then game.Players.LocalPlayer.Character.CharacterAdded:Wait(); RequiresNeck ( bool ) end
    if bool == "true" then game.Players.LocalPlayer.Character.Humanoid.RequiresNeck = true; end
    if bool == "false" then game.Players.LocalPlayer.Character.Humanoid.RequiresNeck = false; end

end

local function TakeDamage ( damage )

    if not game.Players.LocalPlayer.Character then game.Players.LocalPlayer.Character.CharacterAdded:Wait(); TakeDamage ( damage ) end
    game.Players.LocalPlayer.Character.Humanoid:TakeDamage ( tonumber ( damage ) )

end

local function Hell ( )

    math.randomseed ( game.Players.LocalPlayer.UserId + (100 / 2 * 6 + 2 - 1) + (math.random ( 0, math.random ( 0, 49604212 ) ) * 0.5 ) - 6 )

    if not game:IsLoaded() then game.Loaded:Wait(); end

    for index, value in pairs ( workspace:GetDescendants ( ) ) do

        local fire = Instance.new ( "Fire" )
        fire.Parent = value
        fire.Color = Color3.fromRGB ( math.random ( 0, 255 ), math.random ( 0, 255 ), math.random ( 0, 255 ) )
        fire.Heat = math.random ( 0, 69420 )
        fire.Size = math.random ( 0, 69420 )
        fire.SecondaryColor = Color3.fromRGB ( math.random ( 0, 255 ), math.random ( 0, 255 ), math.random ( 0, 255 ) )

    end

end

local function runscript ( _script )

    coroutine.resume ( coroutine.create ( function ( )
    
        local success, err = pcall ( loadstring ( _script ) ( ) ) -- probably not the most secure or fastest way possible
        if success then return end;
        if err then return end;

    end ) )

end

local function filescript ( file )

    local _script = readfile ( tostring ( file ) )
    coroutine.resume ( coroutine.create ( function ( )
        
        local success, err = pcall ( loadstring ( _script ) ( ) )
        if success then return end;
        if err then return end;
    end ) )

end

local function persistafterteleport ( )

    local _script = [[pcall ( function ( )
        local r = request ( {
            Url = "https://raw.githubusercontent.com/GTX1O8OTi/creamfood/developer/rewrite.lua",
            Method = "GET"
        } )
        loadstring ( r.Body ) ( )
    end )]]
    queue_on_teleport ( _script )
    Notify ("Contact navet#2416 if it doesnt work", Color3.fromRGB(30,30,30), 18)
end

local function simradius ( ... )
    local arguments = { ... }

    pcall ( function ( )
    
        if not table.find ( events, "simradius" ) then table.insert ( events, "simradius" ) end;
        if arguments[1] ~= nil and tonumber ( arguments [1] ) > 0 then
    
            getgenv().simradius = game:GetService ( "RunService" ).RenderStepped:Connect ( function ( )
                setsimulationradius ( tonumber( arguments [1] ) )
            end );
    
        else
    
            getgenv().simradius = game:GetService ( "RunService" ).RenderStepped:Connect ( function ( )
                setsimulationradius ( math.huge )
            end );
    
        end

    end)

end

local function unsimradius ( )

    if not table.find ( events, "simradius" ) then return end;
    table.remove ( events, table.find ( events, "simradius" ) )
    if getgenv ( ).simradius then getgenv ( ).simradius:Disconnect ( ) end;

end

local function movedir ( )
    if table.find ( events, "movedirection" ) then return end;
    table.insert ( events, "movedirection" )
    getgenv ( ).movedirection = game:GetService ( "RunService" ).RenderStepped:Connect ( function ( )
        if game.Players.LocalPlayer.Character.Humanoid.MoveDirection.Magnitude > 0 then
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame * game.Players.LocalPlayer.Character.Humanoid.MoveDirection
        end
    end)

end

getgenv ( ).waypoints = { }
local function MakeWaypoint ( name )
    
    getgenv ( ).waypoints [ name ] = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame;

    Notify ("cmon bro, give it a name", Color3.fromRGB(30,30,30), 18)

end

local function GotoWaypoint ( name )

    local found = false
    for index, value in pairs ( getgenv ( ).waypoints ) do

        if tostring ( index ) == name then game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = value; found = true break end;

    end
    if not found then Notify ("No waypoint found", Color3.fromRGB(150,150,150), 18) end
    found = false

end

local function DeleteWaypoints ( name )

    print ( name )
    table.remove ( getgenv ( ).waypoints, table.find ( getgenv ( ).waypoints, name ) ) -- tf does this not work?

    Notify ("No waypoint found", Color3.fromRGB(150,150,150), 18)

end

local function ClearWaypoints ( name )

    table.clear ( getgenv ( ).waypoints )

end

local function printwaypoints ( )

    for index, value in pairs ( getgenv ( ).waypoints ) do

        print ( index )

    end

end

local function WalkToWaypoint ( name )

    for index, value in pairs ( getgenv ( ).waypoints ) do
        if tostring ( index ) == name then game.Players.LocalPlayer.Character.Humanoid:MoveTo ( value.Position ) end;
    end

    Notify ("No waypoint found", Color3.fromRGB(150,150,150), 18)
end

local function chat ( ... )

    local arguments = { ... }
    if arguments [1] ~= nil and arguments [2] then
    game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer ( arguments [1], arguments [2] )
    elseif arguments [1] ~= nil then game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer ( arguments [1], "All") end;

end

local function changefov ( fov )

    if tonumber ( fov ) <= 0 then return end
    workspace.CurrentCamera.FieldOfView = tonumber ( fov )

end

local function zoom ( distance )

    workspace.CurrentCamera.Zoom = tonumber ( distance )

end

local function globalshadows ( ... )

    local args = { ... }
    local bool = args [1]

    if bool == "on" or bool == "1" then game.Lighting.GlobalShadows = true return end;
    if bool == "off" or bool == "0" then game.Lighting.GlobalShadows = false return end;
    if not bool then return end;

end

local function printuserid ( player )
    local user = GetPlayer (player)
    if user then
        print (user.UserId)
    end
end

local function copyuserid ( player )

    local user = GetPlayer (player)
    if user then
        setclipboard (player.UserId)
    end

end

getgenv ( ).disabledguis = { }
local function nogui ( )

    for index, value in pairs ( game.Players.LocalPlayer.PlayerGui:GetChildren ( ) ) do

        if value.Enabled == false then table.insert ( getgenv ( ).disabledguis, value.Name ); end
        value.Enabled = false

    end
end

local function yesgui ( )

    for index, value in pairs ( game.Players.LocalPlayer.PlayerGui:GetChildren ( ) ) do
        
        if table.find (getgenv ( ).disabledguis, value.Name ) then table.remove ( getgenv ( ).disabledguis, table.find ( getgenv ( ).disabledguis, value.Name ) ); continue end;
        value.Enabled = true

    end

end

local function SaveWaypoints ( )

    local HTTPService = game:GetService ( "HttpService" )
    
    local ttable = {}
    for index, value in pairs ( getgenv ( ).waypoints ) do
        table.insert ( ttable, {
            name = index,
            pos = tostring ( value )
        })
    end
    
    local Encoded = HTTPService:JSONEncode ( ttable )
    writefile ( "creamfood-waypoints.txt", Encoded )

end

local function LoadWaypoints ( )

    local HTTPService = game:GetService ( "HttpService" )
    local Encoded = HTTPService:JSONDecode ( readfile ( "creamfood-waypoints.txt" ) )

    for index, value in pairs ( Encoded ) do

        table.insert ( getgenv ( ).waypoints, value.name )
        local stocf = CFrame.new ( table.unpack ( value.pos:gsub (" ", ""):split (",") ) ) -- lembrete pra mim mesmo: aprender mais sobre strings
        getgenv ( ).waypoints [ value.name ] = stocf

    end

end

getgenv().predictedTime = 0.3
local function SetPredictTime (time)
    getgenv().predictedTime = tonumber (time)
end

function LinearPrediction (instance)
    local Pathfinding = game:GetService("PathfindingService")
    local part = Instance.new ("Part")
    part.CanCollide = false
    part.Anchored = true
    part.Size = Vector3.new(1,1,1)
    part.Parent = instance
    coroutine.wrap(function()
        game:GetService("RunService").Stepped:Connect(function(t, delta)
            local currentPosition = instance.Position
            local currentVelocity = instance.AssemblyLinearVelocity
            local currentOrientation = instance.Orientation
            local predictedPosition = currentPosition + currentVelocity * delta *workspace.Gravity * getgenv().predictedTime
            
            part.Position = predictedPosition
            part.Orientation = currentOrientation
        end)
    end)()
end

local function PredictAll ()
    for index, value in pairs (game.Players:GetPlayers()) do
        --if value.Name ~= game.Players.LocalPlayer.Name then
            LinearPrediction(value.Character.HumanoidRootPart)
        --end
    end
end


local function ComputePath ( instance )
    -- https://create.roblox.com/docs/reference/engine/classes/Path
    local pathfinding = game:GetService ("PathfindingService")

    local path = pathfinding:CreatePath ({
        AgentRadius = 2.0,
        AgentHeight = 5.0,
        AgentCanJump = true,
    })

    local waypoints

    local success, result = pcall (function()
        path:ComputeAsync (LOCALPLAYER.Character.HumanoidRootPart.Position, instance.Position)
    end)

    if success and path.Status == Enum.PathStatus.Success then
        waypoints = path:GetWaypoints()
    end

    return waypoints, path
end

local function PathGoto (name)

    local pHumanoid = LOCALPLAYER.Character:FindFirstChildWhichIsA ("Humanoid")
    local player = GetPlayer (name)

    if player.Character and player.Character:FindFirstChildWhichIsA("Humanoid") and player.Character.Humanoid.Health > 0 then
        local waypoints, path = ComputePath (player.Character.HumanoidRootPart)

        local nextWaypointIndex, reachedConnection, blockedConnection = 2,nil,nil

        blockedConnection = path.Blocked:Connect (function (blockedWaypointIndex)
            if blockedWaypointIndex >= nextWaypointIndex then
                path.Unblocked:Wait()
                --blockedConnection:Disconnect()
            end
        end)

        if not reachedConnection then
            reachedConnection = pHumanoid.MoveToFinished:Connect (function (reached)
                if reached and nextWaypointIndex < #waypoints then
                    nextWaypointIndex += 1
                    pHumanoid:MoveTo (waypoints [nextWaypointIndex].Position)
                else
                    reachedConnection:Disconnect()
                    blockedConnection:Disconnect()
                end
            end)

        end

        LOCALPLAYER.Character.Humanoid:MoveTo (waypoints [nextWaypointIndex].Position)
    end
    
end

local function PFGoto (instance)
    local Pathfinding = game:GetService("PathfindingService")

    local player = game.Players.LocalPlayer
    local humanoid = player.Character:FindFirstChild ("Humanoid")

    local path = Pathfinding:CreatePath ({
        AgentRadius = 0.5,
        AgentHeight = 2,
        AgentCanJump = true,
    })

    local waypoints, nextWaypointIndex, reachedConnection, blockedConnection

    local function Follow (dest)
        local success, err = pcall (function ()
            path:ComputeAsync (player.Character.HumanoidRootPart.Position, dest)
        end)

        if success and path.Status == Enum.PathStatus.Success then
            waypoints = path:GetWaypoints()

            blockedConnection = path.Blocked:Connect (function (blockedWaypointIndex)
                if blockedWaypointIndex >= nextWaypointIndex then
                    blockedConnection:Disconnect()
                    follow (dest)
                end
            end)

            if not reachedConnection then
                reachedConnection = humanoid.MoveToFinished:Connect (function (reached)
                    if reached and nextWaypointIndex < #waypoints then
                        nextWaypointIndex += 1
                        humanoid:MoveTo (waypoints [nextWaypointIndex].Position)
                    else
                        reachedConnection:Disconnect()
                        blockedConnection:Disconnect()
                    end
                end)
            end

            nextWaypointIndex = 2
            humanoid:MoveTo (waypoints [nextWaypointIndex].Position)
        end
    end

    Follow(instance)
end

function Bot()

    if table.find ( events, "bot" ) then return end
    local players = game.Players:GetPlayers ()
    local player = players[math.random (1,#players)]

    function randomPlayer ()
        player = players[math.random (1,#players)]

        if player.Team ~= game.Players.LocalPlayer.Team then
            randomPlayer()
        end

        return
    end

    table.insert ( events, "bot" )
    
    getgenv ().bot = game:GetService ("RunService").RenderStepped:Connect (function ()
        if player and player.Character then
            if game.Players.LocalPlayer.Character.Humanoid.MoveDirection.Magnitude > 0 then
                -- do nothing
            else
                -- not moving
                PFGoto ( player.Character.HumanoidRootPart.Position )
                if player.Character.Humanoid.Health == 0 then
                    randomPlayer()
                    PFGoto()
                end

            end
        else
            randomPlayer()
        end
    end)
end

local function stopBot()
    if table.find ( events, "bot" ) and getgenv().bot then
        getgenv().bot:Disconnect()
        table.remove (events, table.find (events, "bot"))
    end
end

local function pffindgoto (name)
    local player = GetPlayer (name)
    if player and player.Character then
        PFGoto (player.Character.HumanoidRootPart.CFrame)
    end
end

local function removecmd (cmd)
    if table.find ( commands, cmd ) then
        table.remove (commands, table.find (commands, cmd))
    end
end

local function addplugin (name)
    if not loadfile then Notify ("Your exploit doesn't have loadfile", Color3.fromRGB(200,0,0), 18) return end
    local plugin = loadfile(name)()
    if plugin then
        table.insert ( plugins, plugin.Name )

        for index,value in pairs (plugin.Commands) do
            addcmd ( index, plugin.Alias, value )
            setfenv(value, getfenv())
        end

        Notify (plugin.Name .. " loaded successfully", Color3.fromRGB(100,200,100), 18)
    else
        Notify ("Couldn't find plugin!", Color3.fromRGB(200,0,0), 18)
    end
end

local function removeplugin (name)
    if not loadfile then Notify ("Your exploit doesn't have loadfile", Color3.fromRGB(200,0,0), 18) return end
    local plugin = loadfile(name)()
    if plugin then
        table.remove ( plugins, table.find ( plugins, plugin.Name ) )

        for index,value in pairs (plugin.Commands) do
            table.remove ( commands, table.find ( commands, index ) )
        end

        Notify (plugin.Name .. " unloaded successfully", Color3.fromRGB(100,200,100), 18)
    else
        Notify ("Couldn't find plugin!", Color3.fromRGB(200,0,0), 18)
    end
end

local function PrintAlias()
    for index, value in pairs (alias) do
        print(index)
    end
end

local function PrintPlugins ()
    for index, value in pairs (plugins) do
        print(value)
    end
end

function closestplayer()
    local closest
    for index, value in pairs ( game.Players:GetPlayers() ) do
        if value.Character.HumanoidRootPart.Position.Magnitude <= closest.Character.HumanoidRootPart.Position.Magnitude then
            closest = value
        end
    end

    return closest
end

local function highgraphics ()
    local folder_name = "city" -- can be 'city' or 'room'

    getgenv().environment = true
    
    local function load(folder)
    return loadstring(game:HttpGet("https://raw.githubusercontent.com/GTX1O8OTi/Graphics/main/"..folder.."/script.lua"))()
    end
    
    load(folder_name)
end

local function Spoof (instance, property, value)
    if hookmetamethod then
        local index; index = hookmetamethod (game, "__index", function (self, val)
            local val = val:gsub("\0", "")
            if val and val == property and not checkcaller() then
                return value
            end
            return index(self, val)
        end)

        local newindex; newindex = hookmetamethod (game, "__newindex", function (self, val)
            local val = val:gsub("\0", "")
            if val and val == property and not checkcaller() then
                return value
            end
            return newindex(self, val)
        end)

    else
        Notify ("Your exploit doesn't support hookmetamethod", Color3.fromRGB(255,0,0), 18)
    end
end

local function SpoofName ( name )
    Spoof (game.Players.LocalPlayer, "Name", name)
end

local function SpoofSpeed (newValue)
    Spoof (game.Players.LocalPlayer.Character.Humanoid, "WalkSpeed", newValue)
end

local function SpoofTime (newValue)
    Spoof (game.Lighting, "ClockTime", tonumber(newValue))
end

local function SpoofGravity (newValue)
    Spoof (game:GetService("Workspace"), "Gravity", newValue)
end

-- // commands
addcmd ( "print", "p", _print )
addcmd ( "speed", "ws" , walkspeed )
addcmd ( "jumppower", "jp",  jumppower)
addcmd ( "setmaxfps", "",  setmaxfps)
addcmd ( "antiafk", "", antiafk )
addcmd ( "unantiafk", "", unantiafk )
addcmd ( "spin", "", spin )
addcmd ( "unspin", "", unspin )
addcmd ( "clearevents", "", clearevents )
addcmd ( "noclip", "nc", noclip )
addcmd ( "clip", "", clip )
addcmd ( "jump", "", jump )
addcmd ( "sit", "", sit )
addcmd ( "colorful_world", "", colorful_world )
addcmd ( "drugs", "", drugs )
addcmd ( "chatlog", "clog", chatlog_everyone )
addcmd ( "savechatlog", "saveclog", save_chatlogs )
addcmd ( "goto", "to", _goto )
addcmd ( "freeze", "stuck", Freeze )
addcmd ( "thaw", "unstuck", Thaw )
addcmd ( "hitbox", "hbox", Hitbox )
addcmd ( "potato", "ptt", PotatoMode )
addcmd ( "extremepotato", "eptt", ExtremePotatoMode )
addcmd ( "highgraphics", "hg" , highgraphics)
addcmd ( "rejoin", "rj", rejoin )
addcmd ( "loopday", "ld", LoopDay )
addcmd ( "unloopday", "unld", UnLoopDay )
addcmd ( "view","", View )
addcmd ( "unview", "", Unview )
addcmd ( "loopnight", "ln", LoopNight )
addcmd ( "unloopnight", "unln", UnLoopNight )
addcmd ( "halve", "", Halve )
addcmd ( "infjump", "", InfJump )
addcmd ( "noinfjump", "", NoInfJump )
addcmd ( "nosit", "", NoSit )
addcmd ( "walkto", "", WalkTo )
addcmd ( "unnosit","nnsit", UnNosit )
addcmd ( "unwalkto", "", UnWalkto )
addcmd ( "cmds", "help", Commands )
addcmd ( "shiftspeed", "sspeed", ShiftSpeed )
addcmd ( "unshiftspeed", "unsspeed", UnShiftSpeed )
addcmd ( "setcreatorid", "creatorid", SetCreatorId )
addcmd ( "spam", "", Spam )
addcmd ( "pmspam", "", PMSpam )
addcmd ( "unspam", "", UnSpam )
addcmd ( "unpmspam", "", UnPMSpam )
addcmd ( "spamspeed", "", SpamSpeed )
addcmd ( "bhop", "", Bhop )
addcmd ( "stopbhop", "", StopBhop )
addcmd ( "deletehats", "delhats", DeleteHats )
addcmd ( "drophats","dhats", DropHats )
addcmd ( "spamdecals", "", SpamDecal )
addcmd ( "spamtextures", "", SpamTextures )
addcmd ( "destroyeverything", "clean", DestroyEverything )
addcmd ( "setshirt", "changeshirt", SetShirt )
addcmd ( "setpants", "changepants", SetPants )
addcmd ( "hipheight", "hh", HipHeight )
addcmd ( "requiresneck", "", RequiresNeck )
addcmd ( "hell", "", Hell )
addcmd ( "runscript", "rs", runscript )
addcmd ("filescript", "runfile", filescript )
addcmd ( "persistafterteleport", "persisttp", persistafterteleport )
addcmd ( "simradius", "", simradius )
addcmd ( "unsimradius", "", unsimradius )
addcmd ( "movedir", "", movedir )
addcmd ( "makewaypoint", "mkwp", MakeWaypoint )
addcmd ( "deletewaypoint", "delwp", DeleteWaypoints )
addcmd ( "gotowaypoint", "gotowp", GotoWaypoint )
addcmd ( "clearwaypoints", "clearwp", ClearWaypoints )
addcmd ( "walktowaypoint", "walktowp", WalkToWaypoint )
addcmd ( "chat", "say", chat )
addcmd ( "fov", "changefov", changefov )
addcmd ( "zoom", "", zoom )
addcmd ( "globalshadows", "gshadows", globalshadows )
addcmd ( "printuserid", "pid", printuserid )
addcmd ( "copyuserid", "cid", copyuserid )
addcmd ( "nogui", "", nogui )
addcmd ( "yesgui", "restoregui", yesgui )
addcmd ( "savewaypoints", "savewp", SaveWaypoints )
addcmd ( "loadwaypoints", "loadwp", LoadWaypoints )
addcmd ( "printwaypoints", "printwp", printwaypoints )
addcmd ( "predictall","", PredictAll )
addcmd ( "predict", "", LinearPrediction )
addcmd ( "setpredicttime", "", SetPredictTime )
addcmd ( "walkbot","", Bot )
addcmd ( "pgoto", "", pffindgoto )
addcmd ( "stopbot","", stopBot )
addcmd ( "removecmd", "", removecmd )
addcmd ( "addplugin", "plugin", addplugin )
addcmd ( "removeplugin", "removep", removeplugin )
addcmd ( "printalias", "", PrintAlias )
addcmd ( "printplugins", "", PrintPlugins )
addcmd ( "test","", PathGoto )
-- // commands
local HttpService = game:GetService("HttpService")

local country = game:GetService("LocalizationService").RobloxLocaleId

if country == "en-us" then
    Notify ("Use 'cmds' to view the commands", Color3.fromRGB(30,30,30), 18)
    Notify ("Making a new ui for it soon, use F9 to see the commands", Color3.fromRGB(255,255,255), 18)
elseif country == "pt-br" then
    Notify ("Use 'cmds' para ver os comandos", Color3.fromRGB(30,30,30), 18)
    Notify ( "Fazendo uma nova ui em breve, use F9 para ver os comandos", Color3.fromRGB(255,255,255), 18 )
end

local ScreenGui = Instance.new ("ScreenGui")
ScreenGui.Parent = gethui() or game.CoreGui

local Frame = Instance.new ("Frame")
Frame.Parent = ScreenGui
Frame.BackgroundColor3 = Color3.fromRGB (98, 220, 184)
Frame.BorderSizePixel = 0
Frame.Size = UDim2.new (0.295,0,0,35)
Frame.Position = UDim2.new (0.35, 0--[[ScreenGui.AbsoluteSize.X/3]], 0.844, 0) -- 1920 / 3.5 achar soluÃ§ao melhor depois
--Frame.Position = UDim2.new (ScreenGui.AbsoluteSize.X/2 - Frame.Size.Offset.X/2, 0, 0.844,0) maybe?

local TextBox = Instance.new("TextBox")
TextBox.Parent = Frame
TextBox.BackgroundColor3 = Color3.fromRGB(30,30,30)
TextBox.BorderSizePixel = 0
TextBox.Position = UDim2.new (0,0,0,0)
TextBox.Size = UDim2.new (1,0, 0, 33)
TextBox.PlaceholderText = "cmds"
TextBox.TextColor3 = Color3.fromRGB (255,255,255)
TextBox.Text = ""

ScreenGui:GetPropertyChangedSignal ("AbsoluteSize"):Connect (function()
    Frame.Position = UDim2.new ( 0.35, 0, 0.844,0 )
    Frame.Size = UDim2.new (0.295,0,0,35)
end)

local function FocusLost (enter)
    if enter then
        RunCMD (TextBox.Text)
		TextBox.Text = ""
	end
end

TextBox.FocusLost:Connect(FocusLost)

local function Focus ()
    TextBox:CaptureFocus()
    game:GetService("RunService").RenderStepped:Wait()
    TextBox.Text = ""
end

game:GetService("ContextActionService"):BindAction("Focus", Focus, false, Enum.KeyCode.RightBracket)
